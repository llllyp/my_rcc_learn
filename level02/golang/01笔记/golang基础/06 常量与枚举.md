# 常量
- 由于常量的值是在编译期确定的，所以常量定义时必须赋值，并且不能使用方法的返回值为常量赋值。
- 常量被定义后，其值不能再被修改。
- 常量（包括全局常量和局部常量）被定义后可以不使用。
- 常量的定义方式与变量定义的方式基本相同，只是 `var` 关键字被更换成了 `const`
```go
// 方式 1
const <name> <type> = <value>
//  方式二, 某些类型可以直接推导出来，不需要声明
const <name> = <value>
// 方式三,
const <name3>, <name4>, ... = <value3>, <value4>, ...
// 方式四
const <name5>, <name6>, ... <type> = <value5>, <value6>, ...
// 方式五, 声明多个时，可以用小括号包裹，此模式不限制声明次数
const (
  <name1> <type1> = <value1>
  <name2> = <value2>
  <name3>, <name4>, ... = <value3>, <value4>, ...
  <name5>, <name6>, ... <type> = <value5>, <value6>, ...
)
// 示例
// 方式1
const a int = 1

// 方式2
const b = "test"

// 方式3
const c, d = 2, "hello"

// 方式4
const e, f bool = true, false

// 方式5
const (
    h    byte = 3
    i         = "value"
    j, k      = "v", 4
    l, m      = 5, false
)

const (
    n = 6
)
```
# 枚举
Go 中没有内置枚举类型，所以 Go 中的枚举是使用 const 来定义枚举的。
```go
const (
    Male = "Male"
    Female = "Female"
)

// 除了直接定义值以外，还会使用类型别名，让常量定义的枚举类型的作用显得更直观
type Gender string

const (
   Male   Gender = "Male"
   Female Gender = "Female"
)

// 使用
func (g *Gender) String() string {
    switch *g {
    case Male:
        return "Male"
    case Female:
        return "Female"
    default:
        return "Unknown"
    }
}

func (g *Gender) IsMale() bool {
    return *g == Male
}
```

# iota 关键字
iota 是一个方便定义常量的关键字。iota 独立作用于每个 const 定义组
如果 iota 定义在 const 定义组中的第 n 行，那么 iota 的值为 n - 1。所以一定要注意 iota 出现在定义组中的第几行，而不是当前代码中它第几次出现。
**iota 仅能与 const 关键字配合使用**

```go
const pre int = 1
const a int = iota // a = 0
const (
    b int = iota // b = 0
    c
    d
    e
)
const (
    f = 2
    g = iota // g = 1
    h
    i
)
```

