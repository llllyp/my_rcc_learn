# 运算操作符
## 算数运算
go 中，两个整数计算，它们计算之后的结果也还是整数。
```go
a, b := 1, 2
sum := a + b
sub := a - b
mul := a * b
div := a / b
mod := a % b

fmt.Println(sum, sub, mul, div, mod)
// 输出：3 -1 2 0 1
```
自增与自减的写法
```go
a := 1
// 正确写法
a++
a--

// 错误的使用方式
++a
--a

// 错误使用方式，不可以自增时计算,也不能赋值
b := a++ + 1
c := a--
```
**当不同的数字类型混合计算时，必须先把它们转换成同一类型才可以计算**
```go
a := 10 + 0.1
b := byte(1) + 1
fmt.Println(a, b)

sum := a + float64(b)
fmt.Println(sum)

sub := byte(a) - b
fmt.Println(sub)

mul := a * float64(b)
div := int(a) / b

fmt.Println(mul, div)
```

## 关系运算
```go
a := 1
b := 5

fmt.Println(a == b)
fmt.Println(a != b)
fmt.Println(a > b)
fmt.Println(a < b)
fmt.Println(a >= b)
fmt.Println(a <= b)
```

## 逻辑运算
```go
a := true
b := false

fmt.Println(a && b)
fmt.Println(a || b)
fmt.Println(!(a && b))
```

## 位运算
```go
fmt.Println(0 & 0)
fmt.Println(0 | 0)
fmt.Println(0 ^ 0)

fmt.Println(0 & 1)
fmt.Println(0 | 1)
fmt.Println(0 ^ 1)

fmt.Println(1 & 1)
fmt.Println(1 | 1)
fmt.Println(1 ^ 1)

fmt.Println(1 & 0)
fmt.Println(1 | 0)
fmt.Println(1 ^ 0)
```

## 赋值运算
```go
func main() {
    a, b := 1, 2
    var c int
    c = a + b
    fmt.Println("c = a + b, c =", c)

    plusAssignment(c, a)
    subAssignment(c, a)
    mulAssignment(c, a)
    divAssignment(c, a)
    modAssignment(c, a)
    leftMoveAssignment(c, a)
    rightMoveAssignment(c, a)
    andAssignment(c, a)
    orAssignment(c, a)
    norAssignment(c, a)
}

func plusAssignment(c, a int) {
    c += a // c = c + a
    fmt.Println("c += a, c =", c)
}

func subAssignment(c, a int) {
    c -= a // c = c - a
    fmt.Println("c -= a, c =", c)
}

func mulAssignment(c, a int) {
    c *= a // c = c * a
    fmt.Println("c *= a, c =", c)
}

func divAssignment(c, a int) {
    c /= a // c = c / a
    fmt.Println("c /= a, c =", c)
}

func modAssignment(c, a int) {
    c %= a // c = c % a
    fmt.Println("c %= a, c =", c)
}

func leftMoveAssignment(c, a int) {
    c <<= a // c = c << a
    fmt.Println("c <<= a, c =", c)
}

func rightMoveAssignment(c, a int) {
    c >>= a // c = c >> a
    fmt.Println("c >>= a, c =", c)
}

func andAssignment(c, a int) {
    c &= a // c = c & a
    fmt.Println("c &= a, c =", c)
}

func orAssignment(c, a int) {
    c |= a // c = c | a
    fmt.Println("c |= a, c =", c)
}

func norAssignment(c, a int) {
    c ^= a // c = c ^ a
    fmt.Println("c ^= a, c =", c)
}
```

## 其他运算
```go
func main() {
    a := 4
    var ptr *int
    fmt.Println(a)

    ptr = &a
    fmt.Printf("*ptr 为 %d\n", *ptr)
}
```

## 运算优先级
```go
func main() {
    var a int = 21
    var b int = 10
    var c int = 16
    var d int = 5
    var e int

    e = (a + b) * c / d // ( 31 * 16 ) / 5
    fmt.Printf("(a + b) * c / d 的值为 : %d\n", e)

    e = ((a + b) * c) / d // ( 31 * 16 ) / 5
    fmt.Printf("((a + b) * c) / d 的值为  : %d\n", e)

    e = (a + b) * (c / d) // 31 * (16/5)
    fmt.Printf("(a + b) * (c / d) 的值为  : %d\n", e)

    // 21 + (160 / 5)
    e = a + (b * c) / d
    fmt.Printf("a + (b * c) / d 的值为  : %d\n", e)

    // 2 & 2 = 2; 2 * 3 = 6; 6 << 1 = 12; 3 + 4 = 7; 7 ^ 3 = 4; 4 | 12 = 12
    f := 3 + 4 ^ 3 | 2 & 2 * 3 << 1
    fmt.Println(f == 12)
}
```

# 流程控制
## if语句
```go
func main() {
    var a int = 10
    if b := 1; a > 10 {
        b = 2
        // c = 2
        fmt.Println("a > 10")
    } else if c := 3; b > 1 {
        b = 3
        fmt.Println("b > 1")
    } else {
        fmt.Println("其他")
        if c == 3 {
            fmt.Println("c == 3")
        }
        fmt.Println(b)
        fmt.Println(c)
    }
}
```

## switch 语句
**switch 默认情况下 case 最后自带 break 语句，匹配成功后就不会执行其他 case，如果我们需要执行后面的 case，可以使用 fallthrough**
```go
func main() {
    a := "test string"

    // 1. 基本用法
    switch a {
    case "test":
        fmt.Println("a = ", a)
    case "s":
        fmt.Println("a = ", a)
    case "t", "test string": // 可以匹配多个值，只要一个满足条件即可
        fmt.Println("catch in a test, a = ", a)
    case "n":
        fmt.Println("a = not")
    default:
        fmt.Println("default case")
    }

    // 变量b仅在当前switch代码块内有效
    switch b := 5; b {
    case 1:
        fmt.Println("b = 1")
    case 2:
        fmt.Println("b = 2")
    case 3, 4:
        fmt.Println("b = 3 or 4")
    case 5:
        fmt.Println("b = 5")
    default:
        fmt.Println("b = ", b)
    }

    // 不指定判断变量，直接在case中添加判定条件
    b := 5
    switch {
    case a == "t":
        fmt.Println("a = t")
    case b == 3:
        fmt.Println("b = 5")
    case b == 5, a == "test string":
        fmt.Println("a = test string; or b = 5")
    default:
        fmt.Println("default case")
    }

    var d interface{}
    // var e byte = 1
    d = 1
    switch t := d.(type) {
    case byte:
        fmt.Println("d is byte type, ", t)
    case *byte:
        fmt.Println("d is byte point type, ", t)
    case *int:
        fmt.Println("d is int type, ", t)
    case *string:
        fmt.Println("d is string type, ", t)
    case *CustomType:
        fmt.Println("d is CustomType pointer type, ", t)
    case CustomType:
        fmt.Println("d is CustomType type, ", t)
    default:
        fmt.Println("d is unknown type, ", t)
    }
}
```
# 循环控制
## for循环
```go
// 方式 1 
for <init>; <condition>;<post> {
    <expression>
    ...
}

// 方式二, 可以仅声明条件判断语句
for <condition> {
    <expression>
    ...
}

// 方式 3，无限循环
for {
    <expression>
    ...
}

// 方式 4，搭配 range 关键字
// 遍历切片，下标参数为可选参数
for <position name>[, <element var name>] := range <slice/array name> {
    <expression>
    ...
}

// 遍历map，value值为可选参数
for <key var name>[, <value var name>] := range <map name> {
    <expression>
    ...
}
```
示例
```go
func main() {
    // 方式1
    for i := 0; i < 10; i++ {
        fmt.Println("方式1，第", i + 1,"次循环")
    }
    
    // 方式2
    b := 1
    for b < 10 {
        fmt.Println("方式2，第", b++,"次循环")
    }
    
    // 方式3，无限循环
    ctx, _ := context.WithDeadline(context.Background(), time.Now().Add(time.Second * 2))
    var started bool
    var stopped atomic.Bool
    for {
        if !started {
            started = true
            // 子 goroutine
            go func() {
                for {
                    select {
                    // 持续监听 cxt.Done() 通道
                    /*
                    ch := make(chan int)
                    ch <- 42 // 发送数据到 channel
                    value := <-ch // 从 channel 接收数据
                    <-ch // 只接收不赋值（常用于信号通知）
                    */
                    case <-ctx.Done():
                        fmt.Println("ctx done")
                        stopped.Store(true)
                        return
                    }
                }
            }()
        }
        fmt.Println("main")
        if stopped.Load() {
            break
        }
    }
    
    // 遍历数组
    var a [10]string
    a[0] = "Hello"
    for i := range a {
        fmt.Println("当前下标：", i)
    }
    for i, e := range a {
        fmt.Println("a[", i, "] = ", e)
    }
    
    // 遍历切片
    s := make([]string, 10)
    s[0] = "Hello"
    for i := range s {
        fmt.Println("当前下标：", i)
    }
    for i, e := range s {
        fmt.Println("s[", i, "] = ", e)
    }
    
    
    m := make(map[string]string)
    m["b"] = "Hello, b"
    m["a"] = "Hello, a"
    m["c"] = "Hello, c"
    for i := range m {
        fmt.Println("当前key：", i)
    }
    for k, v := range m {
        fmt.Println("m[", k, "] = ", v)
    }
}
```