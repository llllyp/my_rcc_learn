1. Go 中没有类的概念。
2. Go 中，全局变量、全局常量、结构体、字段、方法，只有两种公开类型，公开与非公开。非公开是针对包级别的，也就是说如果全局变量声明在不同的源文件中，但是这些源文件属于相同的包，那么这些中的代码可以引用这些不公开的全局变量。不属于相同的包就访问不到了。并且**公开的属性是首字母大写**，非公开的属性首字母是小写，仅按照这个规则来定义是否公开。

# 定义结构体
```go
// 定义1
type <name> struct {
    <Filed_Name1> <type1>
    <Filed_Name2> <type2>
    <Filed_Name3> <type3>
    ...
}

// 示例
type Person struct {
    Name  string
    Age   int
    Call  func() byte
    Map   map[string]string
    Ch    chan string
    Arr   [32]uint8
    Slice []interface{}
    Ptr   *int
    once  sync.Once
}

// 定义 2 多个相同类型的域
type <name> struct {
    <Filed_Name1>，<Filed_Name2>,... <type1>
}

// 示例
type Custom struct {
    field1, field2, field3 byte
}

```

## 定义匿名字段
结构体中的字段不是一定要有字段名，也可以仅定义类型，这种只有类型没有字段名的字段被称为匿名字段。
```go
type Custom struct {
    int
    string
    Other string
}
```

# 定义匿名结构体
- 匿名结构体是没有定义名称的结构体。
- 匿名结构体无法定义自己的类型方法。
```go
// 仅可在函数外声明，这种方式可以看成是声明了一个匿名的结构体，实例化后赋值给了的全局变量
var <Name> = struct {
    <FiledName1> <type1>
    <FiledName2> <type2>
    ...
    <type3>
    <type4>
    ...
} {}

// 在函数或方法中声明匿名结构体并实例化
func method() {
    <var name> := struct {
        <FieldName1> <type1>
        <FieldName2> <type2>
        ...
        <type3>
        <type4>
    } {
        <FieldName1>: <value1>,
        <FieldName2>: <value2>,

        <type3>: <value3>,
        <type4>: <value4>,
    }
}
```
匿名结构体的主要适用场景：
- 构建测试数据，单元测试方法中一般会直接声明一个匿名结构体的切片，通过遍历切片测试方法的各个逻辑分支
- http 处理函数中的 JSON 序列化和反序列化，但是不推荐这么使用，应该定义一个正式的结构体。优点是相比 map[string]interface{}无需检查类型、无需检查 key 是否存在并减少相关的代码检查。

## 定义结构体方法
**在 Go 中，结构体的方法和结构体是分开的，但是一般会在声明结构体的代码下面紧跟着声明结构体的方法。**
```go
// 定义
type <Name> struct {
    ...
}

func (<ref name> <Name>) <methodName>(<param name> <ParameterType>, ...) (<return name> <return type>) {
    ...
}

func (<ref name> *<Name>) <methodName>(<param name> <ParameterType>, ...) (<return name> <return type>) {
    ...
}

// 示例

type A struct {
    a string
}

func (a A) string() string {
    return a.a
}

func (a A) stringA() string {
    return a.a
}

func (a A) setA(v string) {
    a.a = v
}

func (a *A) stringPA() string {
    return a.a
}

func (a *A) setPA(v string) {
    a.a = v
}

type B struct {
    A
    b string
}

func (b B) string() string {
    return b.b
}

func (b B) stringB() string {
    return b.b
}

type C struct {
    B
    a string
    b string
    c string
    d []byte
}

func (c C) string() string {
    return c.c
}

func (c C) modityD() {
    c.d[2] = 3
}

func callStructMethod() {
    var a A
    a = A{
        a: "a",
    }
    a.string()
}

func NewC() C {
    return C{
        B: B{
            A: A{
                a: "ba",
            },
            b: "b",
        },
        a: "ca",
        b: "cb",
        c: "c",
        d: []byte{1, 2, 3},
    }
}

func main() {
    c := NewC()
    cp := &c
    fmt.Println(c.string())
    fmt.Println(c.stringA())
    fmt.Println(c.stringB())

    fmt.Println(cp.string())
    fmt.Println(cp.stringA())
    fmt.Println(cp.stringB())

    c.setA("1a")
    fmt.Println("------------------c.setA")
    fmt.Println(c.A.a)
    fmt.Println(cp.A.a)

    cp.setA("2a")
    fmt.Println("------------------cp.setA")
    fmt.Println(c.A.a)
    fmt.Println(cp.A.a)

    c.setPA("3a")
    fmt.Println("------------------c.setPA")
    fmt.Println(c.A.a)
    fmt.Println(cp.A.a)

    cp.setPA("4a")
    fmt.Println("------------------cp.setPA")
    fmt.Println(c.A.a)
    fmt.Println(cp.A.a)

    cp.modityD()
    fmt.Println("------------------cp.modityD")
    fmt.Println(cp.d)
}
```



