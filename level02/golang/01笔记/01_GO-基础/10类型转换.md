# 数字类型转换
数字类型之间相互转换比较简单，并且位数较多的类型向位数较少的类型转换时，高位数据会被直接截去。

强转（类型转换）的底层逻辑是直接操作内存中的二进制数据，不涉及 “数值大小的缩放”（与 int32(100) float64 这种保留数值的转换不同）。
int32 转 byte 时，由于目标类型的存储空间更小（4 字节→1 字节），只能保留最低位的 1 个字节，高位字节自然被丢弃。

```go
package main

import "fmt"

func main() {
    var i int32 = 17
    var b byte = 5
    var f float32
    
    // 数字类型可以直接强转
    f = float32(i) / float32(b)
    fmt.Printf("f 的值为: %f\n", f)
    
    // 当int32类型强转成byte时，高位被直接舍弃
    var i2 int32 = 256
    var b2 byte = byte(i2)
    fmt.Printf("b2 的值为: %d\n", b2)

    /*
    int32：32 位有符号整数，占用 4 个字节（1 字节 = 8 位），能表示的范围是 -2^31 ~ 2^31-1（即 -2147483648 ~ 2147483647）。
    存储时用 32 位二进制表示，例如十进制 260 的二进制是：
    00000000 00000000 00000001 00000100（4 个字节，从高位到低位）。

    byte：Go 中 byte 是 uint8 的别名，8 位无符号整数，占用 1 个字节，能表示的范围是 0 ~ 255。
    存储时用 8 位二进制表示，例如 4 的二进制是 00000100。

    当 int32 强转为 byte 时，由于 byte 只能容纳 8 位，会直接截取原 32 位二进制的最后 8 位（最低位的 1 个字节），
    丢弃前面的 24 位（高位的 3 个字节）。
    */
}
```
## 特殊情况
> int32 是有符号类型，负数用补码表示（最高位为 1）。强转为 byte 时，同样只保留最后 8 位（补码的最低 8 位），结果可能是一个较大的正数（因为 byte 是无符号的）。 

> 例如 int32(-1) 的 32 位补码是 11111111 11111111 11111111 11111111，强转为 byte 后保留最后 8 位 11111111，对应十进制 255。

# 字符串类型转换
string 类型、[]byte 类型与[]rune 类型之间可以类似数字类型那样相互转换，并且数据不会有任何丢失
```go
package main

import "fmt"

func main() {
    str := "hello, 123, 你好"
    var bytes []byte = []byte(str)
    var runes []rune = []rune(str)
    fmt.Printf("bytes 的值为: %v \n", bytes) // [104 101 108 108 111 44 32 49 50 51 44 32 203 227 203 237]
    fmt.Printf("runes 的值为: %v \n", runes) // [104 101 108 108 111 44 32 49 50 51 44 32 203 227 203 237]

    str2 := string(bytes)
    str3 := string(runes)
    fmt.Printf("str2 的值为: %v \n", str2) // hello, 123, 你好
    fmt.Printf("str3 的值为: %v \n", str3) // hello, 123, 你好
}
```
strconv库 可以把数字转成字符串，也可以把字符串转换成数字。
```go
package main

import (
    "fmt"
    "strconv"
)

func main() {
    str := "123"
    num, err := strconv.Atoi(str) // 字符串转换为int
    if err != nil {
        panic(err)
    }
    fmt.Printf("字符串转换为int: %d \n", num)
    str1 := strconv.Itoa(num) // int转换为字符串
    fmt.Printf("int转换为字符串: %s \n", str1)

    // func ParseUint(s string, base int, bitSize int) (uint64, error) 用于将字符串转换为无符号整数（uint64 类型）
    // 参数 10 表示字符串 str 所表示的数字的进制基数（即 “十进制”）。
    // 参数 32 表示目标无符号整数的位大小（32 位）。
    /*
    当 base=10 时，解析为十进制的 123
    当 base=8 时，解析为八进制的 123（对应十进制的 83）
    当 base=16 时，解析为十六进制的 123（对应十进制的 291）
    */
    ui64, err := strconv.ParseUint(str, 10, 32) // 字符串转换为uint64
    fmt.Printf("字符串转换为uint64: %d \n", ui64) // 123

    //参数 2 表示目标字符串的进制基数（即 “二进制”），作用是指定将无符号整数 ui64 转换为二进制格式的字符串。
    str2 := strconv.FormatUint(ui64, 2) // uint64转换为字符串
    fmt.Printf("uint64转换为字符串: %s \n", str2) // 1111011
}
```

# 接口类型转换
接口类型只能通过断言将转换为指定类型。
```go
<variable_name>.(<type_name>)
```
## 示例
```go
package main

import "fmt"

func main() {
    var i interface{} = 3
    a, ok := i.(int)
    if ok {
        fmt.Printf("'%d' is a int \n", a)
    } else {
        fmt.Println("conversion failed")
    }
}
```


# 结构体类型转换
当两个结构体中的字段名称以及类型都完全相同，仅结构体名称不同时，这两个结构体类型即可相互转换。
```go
package main

import "fmt"

type SameFieldA struct {
    name  string
    value int
}

type SameFieldB struct {
    name  string
    value int
}

func (s *SameFieldB) getValue() int {
    return s.value
}

func main() {
    a := SameFieldA{
        name:  "a",
        value: 1,
    }

    b := SameFieldB(a)
    fmt.Printf("conver SameFieldA to SameFieldB, value is : %d \n", b.getValue())
    
    // 只能结构体类型实例之间相互转换，指针不可以相互转换
    // var c interface{} = &a
    // _, ok := c.(*SameFieldB)
    // fmt.Printf("c is *SameFieldB: %v \n", ok)
}
```